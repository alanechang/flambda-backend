(* {{TEST_HEADER}}
 readonly_files = "{{BOXED_TYPE}}_u_array.ml"
 modules = "${readonly_files}"

 * bytecode
   flags = "-extension layouts_alpha"
 * bytecode
   flags = "-extension layouts_beta"
 * native
   flags = "-extension layouts_alpha"
 * native
   flags = "-extension layouts_beta"
*)

(* {{WARNING_COMMENT}} *)

open Printf

module type S = sig
  type t
  val length : t -> int
  val get : t -> int -> {{BOXED_TYPE}}
  val set : t -> int -> {{BOXED_TYPE}} -> unit
  val make : int -> {{BOXED_TYPE}} -> t
  val init : int -> (int -> {{BOXED_TYPE}}) -> t
  val append : t -> t -> t
  val concat : t list -> t
  val sub : t -> int -> int -> t
  val copy : t -> t
  val fill : t -> int -> int -> {{BOXED_TYPE}} -> unit
  val blit : t -> int -> t -> int -> int -> unit
  val to_list : t -> {{BOXED_TYPE}} list
  val of_list : {{BOXED_TYPE}} list -> t
  val iter : ({{BOXED_TYPE}} -> unit) -> t -> unit
  val iteri : (int -> {{BOXED_TYPE}} -> unit) -> t -> unit
  val map : ({{BOXED_TYPE}} -> {{BOXED_TYPE}}) -> t -> t
  val mapi : (int -> {{BOXED_TYPE}} -> {{BOXED_TYPE}}) -> t -> t
  val fold_left : ('a -> {{BOXED_TYPE}} -> 'a) -> 'a -> t -> 'a
  val fold_right : ({{BOXED_TYPE}} -> 'a -> 'a) -> t -> 'a -> 'a
  val iter2 : ({{BOXED_TYPE}} -> {{BOXED_TYPE}} -> unit) -> t -> t -> unit
  val map2 : ({{BOXED_TYPE}} -> {{BOXED_TYPE}} -> {{BOXED_TYPE}}) -> t -> t -> t
  val for_all : ({{BOXED_TYPE}} -> bool) -> t -> bool
  val exists : ({{BOXED_TYPE}} -> bool) -> t -> bool
  val mem : {{BOXED_TYPE}} -> t -> bool
  val sort : ({{BOXED_TYPE}} -> {{BOXED_TYPE}} -> int) -> t -> unit
  val stable_sort : ({{BOXED_TYPE}} -> {{BOXED_TYPE}} -> int) -> t -> unit
  val fast_sort : ({{BOXED_TYPE}} -> {{BOXED_TYPE}} -> int) -> t -> unit
  val to_seq : t -> {{BOXED_TYPE}} Seq.t
  val to_seqi : t -> (int * {{BOXED_TYPE}}) Seq.t
  val of_seq : {{BOXED_TYPE}} Seq.t -> t
  val map_to_array : ({{BOXED_TYPE}} -> 'a) -> t -> 'a array
  val map_from_array : ('a -> {{BOXED_TYPE}}) -> 'a array -> t
  val unsafe_get : t -> int -> {{BOXED_TYPE}}
  val unsafe_set : t -> int -> {{BOXED_TYPE}} -> unit
  val equal : t -> t -> bool
  (* From Sys, rather than Float.Array *)
  val max_length : int
end

module {{BOXED_MODULE}}_array : S = struct
  include Stdlib.Array
  let map_to_array f a = map f a
  let map_from_array f a = map f a
  type t = {{BOXED_TYPE}} array
  let max_length = Sys.max_array_length
  let equal = for_all2 (fun x y -> x = y)
end

module Std_{{MODULE_NAME}} = {{MODULE_NAME}}
module {{MODULE_NAME}} : S = struct
  include {{MODULE_NAME}}

  module {{ELEMENT_MODULE}} = Stdlib__{{ELEMENT_MODULE}}

  let to_boxed = {{ELEMENT_MODULE}}.to_{{BOXED_TYPE}}
  let of_boxed = {{ELEMENT_MODULE}}.of_{{BOXED_TYPE}}

  type t = {{UNBOXED_TYPE}} array

  let empty () = make 0 (of_boxed 0{{SUFFIX}})
  let to_seq a =
    let rec aux i () =
      if i < length a
      then
        let x = unsafe_get a i in
        Seq.Cons (to_boxed x, aux (i+1))
      else Seq.Nil
    in
    aux 0

  let to_seqi a =
    let rec aux i () =
      if i < length a
      then
        let x = unsafe_get a i in
        Seq.Cons ((i,to_boxed x), aux (i+1))
      else Seq.Nil
    in
    aux 0

  let of_rev_list = function
      [] -> empty ()
    | hd::tl as l ->
      let len = List.length l in
      let a = make len (of_boxed hd) in
      let rec fill i = function
          [] -> a
        | hd::tl -> unsafe_set a i (of_boxed hd); fill (i-1) tl
      in
      fill (len-2) tl

  let of_seq i =
    let l = Seq.fold_left (fun acc x -> x::acc) [] i in
    of_rev_list l


  let to_list t = fold_right (fun f l -> (to_boxed f)::l) t []
  (* let res = ref [] in
   * iter (fun f -> res := (to_boxed f) :: !res);
   * List.rev res *)

  let of_list l =
    let len = List.length l in
    let res = create len #0{{SUFFIX}} in
    List.iteri (fun idx f -> set res idx (of_boxed f)) l;
    res
  let max_length = Sys.max_array_length
  let get t idx = to_boxed (get t idx)
  let set t idx v = set t idx (of_boxed v)

  let make l f = make l (of_boxed f)
  let init l f = init l (fun i -> of_boxed (f i))
  let fill a ofs len v = fill a ofs len (of_boxed v)
  let iter f t = iter (fun v -> f (to_boxed v)) t
  let iteri f t = iteri (fun i v -> f i (to_boxed v)) t
  let map f t = map (fun v -> of_boxed (f (to_boxed v))) t
  let mapi f t = mapi (fun i v -> of_boxed (f i (to_boxed v))) t
  let fold_left f acc t = fold_left (fun acc v -> f acc (to_boxed v)) acc t
  let fold_right f t acc = fold_right (fun v acc -> f (to_boxed v) acc) t acc

  let iter2 f a b = iter2 (fun v1 v2 -> f (to_boxed v1) (to_boxed v2)) a b
  let map2 f a b = map2 (fun v1 v2 -> of_boxed (f (to_boxed v1) (to_boxed v2))) a b
  let for_all f t = for_all (fun v -> f (to_boxed v)) t
  let exists f t = exists (fun v -> f (to_boxed v)) t
  let mem v t = mem (of_boxed v) t
  let sort f t = sort (fun a b -> f (to_boxed a) (to_boxed b)) t
  let stable_sort f t = stable_sort (fun a b -> f (to_boxed a) (to_boxed b)) t
  let fast_sort f t = fast_sort (fun a b -> f (to_boxed a) (to_boxed b)) t

  let map_to_array f t =
    if length t = 0 then [||] else begin
      let res = Array.make (length t) (f (get t 0)) in
      iteri (fun idx v -> if idx > 0 then Array.set res idx (f v)) t;
      res
    end

  let map_from_array f a =
    if Array.length a = 0 then empty () else begin
      let res = make (Array.length a) (f (Array.get a 0)) in
      Array.iteri (fun idx v -> if idx > 0 then set res idx (f v)) a;
      res
    end

  let unsafe_get t idx = to_boxed (unsafe_get t idx)
  let unsafe_set t idx v = unsafe_set t idx (of_boxed v)
  let equal = for_all2 (fun x y -> to_boxed x = to_boxed y)
end


module Test (A : S) : sig end = struct

  (* auxiliary functions *)

  let module I = {{BOXED_MODULE}} in
  let rec check_i_upto a i =
    if i >= 0 then begin
      assert (A.get a i = I.of_int i);
      check_i_upto a (i - 1);
    end
  in

  let check_i a = check_i_upto a (A.length a - 1) in

  let check_inval f arg =
    match f arg with
    | _ -> assert false
    | exception (Invalid_argument _) -> ()
    | exception _ -> assert false
  in

  (* [make] [set] [get] *)
  let a = A.make 1000 1{{SUFFIX}} in
  for i = 0 to 499 do A.set a i (I.of_int i) done;
  let rec loop i =
    if i >= 0 then begin
      assert (A.get a i = (if i < 500 then I.of_int i else 1{{SUFFIX}}));
      loop (i - 1);
    end
  in loop 999;
  check_inval (A.get a) (-1);
  check_inval (A.get a) (1000);
  check_inval (fun i -> A.set a i 1{{SUFFIX}}) (-1);
  check_inval (fun i -> A.set a i 1{{SUFFIX}}) 1000;
  check_inval (fun i -> A.make i 1{{SUFFIX}}) (-1);
  check_inval (fun i -> A.make i 1{{SUFFIX}}) (A.max_length + 1);

  let a = A.make 1001 1{{SUFFIX}} in
  for i = 0 to 499 do A.set a i (I.of_int i) done;
  let rec loop i =
    if i >= 0 then begin
      assert (A.get a i = (if i < 500 then I.of_int i else 1{{SUFFIX}}));
      loop (i - 1);
    end
  in loop 1000;
  check_inval (A.get a) (-1);
  check_inval (A.get a) (1001);
  check_inval (fun i -> A.set a i 1{{SUFFIX}}) (-1);
  check_inval (fun i -> A.set a i 1{{SUFFIX}}) 1001;

  (* [length] *)
  let test_length l = assert (l = (A.length (A.make l 1{{SUFFIX}}))) in
  test_length 0;
  test_length 1;
  test_length 10;
  test_length 25;
  test_length 255;
  test_length 256;
  test_length 1000;
  test_length 1001;
  test_length 123456;

  (* [init] *)
  let a = A.init 1000 I.of_int in
  check_i a;
  let a = A.init 1001 I.of_int in
  check_i a;
  check_inval (fun i -> A.init i I.of_int) (-1);
  check_inval (fun i -> A.init i I.of_int) (A.max_length + 1);

  (* [append] *)
  let check m n =
    let a = A.init m I.of_int in
    let b = A.init n (fun x -> I.of_int (x + m)) in
    let c = A.append a b in
    assert (A.length c = (m + n));
    check_i c;
  in
  check 0 0;
  check 0 100;
  check 1 100;
  check 100 0;
  check 100 1;
  check 100 100;
  check 1000 1000;
  check 1000 1001;
  check 1001 1000;
  check 1001 1001;
  (* check_inval omitted *)

  (* [concat] *)
  let check l =
    let f (len, acc) n =
      (len + n, A.init n (fun i -> I.of_int (len + i)) :: acc)
    in
    let (total, ll) = List.fold_left f (0, []) l in
    let b = A.concat (List.rev ll) in
    assert (A.length b = total);
    check_i b;
  in
  check [0; 0; 0];
  check [1; 10; 100];
  check [10; 0];
  check [0];
  check [1000; 1000; 1000];
  check [];
  check [1001; 1000; 1000];
  check [1000; 1001; 1000];
  check [1000; 1000; 1001];
  check [1001; 1001; 1001];
  (* check_inval omitted *)

  (* [sub] *)
  let a = A.init 1000 (fun i -> I.of_int (i - 100)) in
  let b = A.sub a 100 200 in
  check_i b;
  assert (A.length b = 200);
  let b = A.sub a 1000 0 in
  check_i (A.sub a 1000 0);
  assert  (A.length b = 0);
  check_inval (A.sub a (-1)) 0;
  check_inval (A.sub a 0) (-1);
  check_inval (A.sub a 0) 1001;
  check_inval (A.sub a 1000) 1;

  let a = A.init 1001 (fun i -> I.of_int (i - 101)) in
  let b = A.sub a 101 199 in
  check_i b;
  assert (A.length b = 199);
  let b = A.sub a 1001 0 in
  check_i (A.sub a 1001 0);
  assert  (A.length b = 0);
  check_inval (A.sub a (-1)) 0;
  check_inval (A.sub a 0) (-1);
  check_inval (A.sub a 0) 1002;
  check_inval (A.sub a 1001) 1;

  (* [copy] *)
  let check len =
    let a = A.init len I.of_int in
    let b = A.copy a in
    check_i b;
    assert (A.length b = len);
  in
  check 0;
  check 1;
  check 128;
  check 1023;

  (* [blit] [fill] *)
  let test_blit_fill data initval ofs len =
    let a = A.of_list data in
    let b = A.make (List.length data) 1{{SUFFIX}} in
    A.blit a 0 b 0 (A.length b);
    assert (A.equal a b);
    A.fill b ofs len initval;
    let rec check i = function
      | [] -> ()
      | hd :: tl ->
          assert (A.get b i = (if i >= ofs && i < ofs + len
                               then initval else hd));
          check (i + 1) tl;
    in
    check 0 data
  in
  test_blit_fill [1{{SUFFIX}};2{{SUFFIX}};5{{SUFFIX}};8{{SUFFIX}};-100{{SUFFIX}};2120000000{{SUFFIX}}] 3{{SUFFIX}} 3 2;
  let a = A.make 100 0{{SUFFIX}} in
  check_inval (A.fill a (-1) 0) 1{{SUFFIX}};
  check_inval (A.fill a 0 (-1)) 1{{SUFFIX}};
  check_inval (A.fill a 0 101) 1{{SUFFIX}};
  check_inval (A.fill a 100 1) 1{{SUFFIX}};
  check_inval (A.fill a 101 0) 1{{SUFFIX}};
  check_inval (A.blit a (-1) a 0) 0;
  check_inval (A.blit a 0 a 0) (-1);
  check_inval (A.blit a 0 a 0) 101;
  check_inval (A.blit a 100 a 0) 1;
  check_inval (A.blit a 101 a 0) 0;
  check_inval (A.blit a 0 a (-1)) 0;
  check_inval (A.blit a 0 a 100) 1;
  check_inval (A.blit a 0 a 101) 0;
  let a = A.make 101 0{{SUFFIX}} in
  check_inval (A.fill a (-1) 0) 1{{SUFFIX}};
  check_inval (A.fill a 0 (-1)) 1{{SUFFIX}};
  check_inval (A.fill a 0 102) 1{{SUFFIX}};
  check_inval (A.fill a 101 1) 1{{SUFFIX}};
  check_inval (A.fill a 102 0) 1{{SUFFIX}};
  check_inval (A.blit a (-1) a 0) 0;
  check_inval (A.blit a 0 a 0) (-1);
  check_inval (A.blit a 0 a 0) 102;
  check_inval (A.blit a 101 a 0) 1;
  check_inval (A.blit a 102 a 0) 0;
  check_inval (A.blit a 0 a (-1)) 0;
  check_inval (A.blit a 0 a 101) 1;
  check_inval (A.blit a 0 a 102) 0;
  let test_blit_overlap a ofs1 ofs2 len =
    let a = A.of_list a in
    let b = A.copy a in
    A.blit a ofs1 a ofs2 len;
    for i = 0 to len - 1 do
      assert (A.get b (ofs1 + i) = A.get a (ofs2 + i))
    done
  in
  test_blit_overlap [1{{SUFFIX}}; 2{{SUFFIX}}; 3{{SUFFIX}}; 4{{SUFFIX}}] 1 2 2;

  (* [to_list] [of_list] *)
  let a = A.init 1000 I.of_int in
  assert (A.equal a (A.of_list (A.to_list a)));
  let a = A.init 1001 I.of_int in
  assert (A.equal a (A.of_list (A.to_list a)));
  let a = A.init 0 I.of_int in
  assert (A.equal a (A.of_list (A.to_list a)));
  (* check_inval omitted *)

  (* [iter] *)
  let a = A.init 300 (I.of_int) in
  let r = ref 0{{SUFFIX}} in
  A.iter (fun x -> assert (x = !r); r := I.add x 1{{SUFFIX}}) a;
  A.iter (fun _ -> assert false) (A.make 0 0{{SUFFIX}});
  assert (!r = 300{{SUFFIX}});

  let a = A.init 301 (I.of_int) in
  let r = ref 0{{SUFFIX}} in
  A.iter (fun x -> assert (x = !r); r := I.add x 1{{SUFFIX}}) a;
  assert (!r = 301{{SUFFIX}});

  (* [iteri] *)
  let a = A.init 300 I.of_int in
  let r = ref 0 in
  let f i x =
    assert (i = !r);
    assert (x = I.of_int i);
    r := i + 1
  in
  A.iteri f a;
  A.iteri (fun _ _ -> assert false) (A.make 0 0{{SUFFIX}});
  assert (!r = 300);

  let a = A.init 301 I.of_int in
  let r = ref 0 in
  let f i x =
    assert (i = !r);
    assert (x = I.of_int i);
    r := i + 1
  in
  A.iteri f a;
  A.iteri (fun _ _ -> assert false) (A.make 0 0{{SUFFIX}});
  assert (!r = 301);

  (* [map], test result and order of evaluation *)
  let a = A.init 500 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x =
    assert (x = !r);
    r := I.add !r 1{{SUFFIX}};
    I.sub x 1{{SUFFIX}}
  in
  let b = A.map f a in
  check_i (A.sub b 1 499);

  let a = A.init 501 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x =
    assert (x = !r);
    r := I.add !r 1{{SUFFIX}};
    I.sub x 1{{SUFFIX}}
  in
  let b = A.map f a in
  check_i (A.sub b 1 500);

  (* [mapi], test result and order of evaluation *)
  let a = A.init 500 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f i x =
    assert (x = I.of_int i);
    assert (x = !r);
    r := I.add !r 1{{SUFFIX}};
    I.sub x 1{{SUFFIX}}
  in
  let b = A.mapi f a in
  check_i (A.sub b 1 499);

  let a = A.init 501 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f i x =
    assert (x = I.of_int i);
    assert (x = !r);
    r := I.add !r 1{{SUFFIX}};
    I.sub x 1{{SUFFIX}}
  in
  let b = A.mapi f a in
  check_i (A.sub b 1 500);

  (* [fold_left], test result and order of evaluation *)
  let a = A.init 500 I.of_int in
  let f acc x =
    assert (acc = x);
    I.add x 1{{SUFFIX}}
  in
  let acc = A.fold_left f 0{{SUFFIX}} a in
  assert (acc = 500{{SUFFIX}});

  let a = A.init 501 I.of_int in
  let acc = A.fold_left f 0{{SUFFIX}} a in
  assert (acc = 501{{SUFFIX}});

  (* [fold_right], test result and order of evaluation *)
  let a = A.init 500 I.of_int in
  let f x acc =
    assert (x = I.sub acc 1{{SUFFIX}});
    x
  in
  let acc = A.fold_right f a 500{{SUFFIX}} in
  assert (acc = 0{{SUFFIX}});

  let a = A.init 501 I.of_int in
  let acc = A.fold_right f a 501{{SUFFIX}} in
  assert (acc = 0{{SUFFIX}});

  (* [iter2], test result and order of evaluation *)
  let a = A.init 123 I.of_int in
  let b = A.init 123 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x y =
    assert (x = !r);
    assert (y = !r);
    r := I.add!r 1{{SUFFIX}};
  in
  A.iter2 f a b;
  let c = A.make 456 0{{SUFFIX}} in
  check_inval (A.iter2 (fun _ _ -> assert false) a) c;
  check_inval (A.iter2 (fun _ _ -> assert false) c) a;

  let a = A.init 124 I.of_int in
  let b = A.init 124 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x y =
    assert (x = !r);
    assert (y = !r);
    r := I.add !r 1{{SUFFIX}};
  in
  A.iter2 f a b;

  (* [map2], test result and order of evaluation *)
  let a = A.init 456 I.of_int in
  let b = A.init 456 (fun i -> I.(mul (of_int i) 2{{SUFFIX}})) in
  let r = ref 0{{SUFFIX}} in
  let f x y =
    assert (x = !r);
    assert (y = I.mul !r 2{{SUFFIX}});
    r := I.add !r 1{{SUFFIX}};
    I.(neg (sub x y))
  in
  let c = A.map2 f a b in
  check_i c;
  let d = A.make 455 0{{SUFFIX}} in
  check_inval (A.map2 (fun _ _ -> assert false) a) d;
  check_inval (A.map2 (fun _ _ -> assert false) d) a;

  let a = A.init 457 I.of_int in
  let b = A.init 457 (fun i -> I.(mul (of_int i) 2{{SUFFIX}})) in
  let r = ref 0{{SUFFIX}} in
  let f x y =
    assert (x = !r);
    assert (y = I.mul !r 2{{SUFFIX}});
    r := I.add !r 1{{SUFFIX}};
    I.(neg (sub x y))
  in
  let c = A.map2 f a b in
  check_i c;

  (* [for_all], test result and order of evaluation *)
  let a = A.init 777 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x =
    assert (x = !r);
    r := I.add x 1{{SUFFIX}};
    true
  in
  assert (A.for_all f a);
  let f x = assert (x = 0{{SUFFIX}}); false in
  assert (not (A.for_all f a));

  let a = A.init 778 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x =
    assert (x = !r);
    r := I.add x 1{{SUFFIX}};
    true
  in
  assert (A.for_all f a);
  let f x = assert (x = 0{{SUFFIX}}); false in
  assert (not (A.for_all f a));

  (* [exists], test result and order of evaluation *)
  let a = A.init 777 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x =
    assert (x = !r);
    r := I.add x 1{{SUFFIX}};
    false
  in
  assert (not (A.exists f a));
  let f x = assert (x = 0{{SUFFIX}}); true in
  assert (A.exists f a);

  let a = A.init 778 I.of_int in
  let r = ref 0{{SUFFIX}} in
  let f x =
    assert (x = !r);
    r := I.add x 1{{SUFFIX}};
    false
  in
  assert (not (A.exists f a));
  let f x = assert (x = 0{{SUFFIX}}); true in
  assert (A.exists f a);

  (* [mem] *)
  let a = A.init 7777 I.of_int in
  assert (A.mem 0{{SUFFIX}} a);
  assert (A.mem 7776{{SUFFIX}} a);
  assert (not (A.mem (-1{{SUFFIX}}) a));
  assert (not (A.mem 7777{{SUFFIX}} a));
  let check v =
    A.set a 1000 v;
    assert (A.mem v a);
  in
  List.iter check [I.max_int; I.min_int; -1{{SUFFIX}}; 0{{SUFFIX}}];

  let a = A.init 7778 I.of_int in
  assert (A.mem 0{{SUFFIX}} a);
  assert (A.mem 7777{{SUFFIX}} a);
  assert (not (A.mem (-1{{SUFFIX}}) a));
  assert (not (A.mem 7778{{SUFFIX}} a));
  let check v =
    A.set a 1001 v;
    assert (A.mem v a);
  in
  List.iter check [I.max_int; I.min_int; -1{{SUFFIX}}; 0{{SUFFIX}}];

  (* [sort] [fast_sort] [stable_sort] *)
  let check_sort sort cmp a =
    let rec check_sorted a i =
      if i + 1 < A.length a then begin
        assert (cmp (A.get a i) (A.get a (i + 1)) <= 0);
        check_sorted a (i + 1);
      end
    in
    let rec check_permutation a b i =
      let p = Array.make (A.length a) true in
      let rec find lo hi x =
        assert (lo < hi);
        if hi = lo + 1 then begin
          assert (cmp (A.get a lo) x = 0);
          assert (p.(lo));
          p.(lo) <- false;
        end else begin
          let mid = (lo + hi) / 2 in
          assert (lo < mid && mid < hi);
          match cmp (A.get a (mid - 1)) x with
          | 0 when p.(mid - 1) -> find lo mid x
          | 0 -> find mid hi x
          | c when c < 0 -> find mid hi x
          | c when c > 0 -> find lo mid x
          | _ -> assert false
        end
      in
      A.iter (find 0 (A.length a)) b
    in
    let b = A.copy a in
    sort cmp a;
    check_sorted a 0;
    check_permutation a b 0;
  in
  Random.init 123;
  let rand_val _ =
    match Random.int 1000 with
    | n when n < 500 -> Random.{{BOXED_TYPE}} I.max_int
    | _ -> I.neg (Random.{{BOXED_TYPE}} I.max_int)
  in
  let check s =
    let a = A.init 5 I.of_int in
    check_sort s Stdlib.compare a; (* already sorted *)
    check_sort s (fun x y -> Stdlib.compare y x) a; (* reverse-sorted *)

    let a = A.init 6 I.of_int in
    check_sort s Stdlib.compare a; (* already sorted *)
    check_sort s (fun x y -> Stdlib.compare y x) a; (* reverse-sorted *)

    let a = A.of_list [I.max_int; I.min_int; -1{{SUFFIX}}; 0{{SUFFIX}}] in
    check_sort s Stdlib.compare a; (* already sorted *)
    check_sort s (fun x y -> Stdlib.compare y x) a; (* reverse-sorted *)

    let a = A.init 50000 rand_val in
    check_sort s Stdlib.compare a;
    let a = A.init 50001 rand_val in
    check_sort s Stdlib.compare a;
    let a = A.make 1000 1{{SUFFIX}} in
    check_sort s Stdlib.compare a;
    let a = A.make 1001 1{{SUFFIX}} in
    check_sort s Stdlib.compare a;
    let a = A.append (A.make 1000 1{{SUFFIX}}) (A.make 1000 2{{SUFFIX}}) in
    check_sort s Stdlib.compare a;
    let a = A.append (A.make 1001 1{{SUFFIX}}) (A.make 1001 2{{SUFFIX}}) in
    check_sort s Stdlib.compare a;
  in
  check A.sort;
  check A.stable_sort;
  check A.fast_sort;

  (* [to_seq] *)
  let check_seq a =
    let r = ref 0 in
    let f x =
      assert (A.get a !r = x);
      r := !r + 1;
    in
    let s = A.to_seq a in
    Seq.iter f s;
  in
  check_seq (A.init 999 I.of_int);
  check_seq (A.init 1000 I.of_int);
  check_seq (A.make 0 0{{SUFFIX}});

  (* [to_seqi] *)
  let check_seqi a =
    let r = ref 0 in
    let f (i, x) =
      assert (i = !r);
      assert (A.get a !r = x);
      r := !r + 1;
    in
    let s = A.to_seqi a in
    Seq.iter f s;
  in
  check_seqi (A.init 999 I.of_int);
  check_seqi (A.init 1000 I.of_int);
  check_seqi (A.make 0 0{{SUFFIX}});

  (* [of_seq] *)
  let r = ref 0 in
  let rec f () =
    if !r = 100 then Seq.Nil else begin
      let res = Seq.Cons (I.of_int !r, f) in
      r := !r + 1;
      res
    end
  in
  let a = A.of_seq f in
  assert (A.equal a (A.init 100 I.of_int));
  assert (A.equal (A.of_seq Seq.empty) (A.make 0 0{{SUFFIX}}));

  (* [map_to_array] *)
  let r = ref 0 in
  let f x =
    assert (x = I.of_int !r);
    r := !r + 1;
    I.mul x 2{{SUFFIX}}
  in
  let a = A.init 876 I.of_int in
  let ar1 = A.map_to_array f a in
  let ar2 = Array.init 876 (fun x -> I.of_int (2 * x)) in
  assert (ar1 = ar2);
  let ar = A.map_to_array (fun _ -> assert false) (A.make 0 0{{SUFFIX}}) in
  assert (ar = [| |]);

  (* [map_from_array] *)
  let r = ref 0 in
  let f x =
    assert (x = I.of_int !r);
    r := !r + 1;
    I.mul x 2{{SUFFIX}}
  in
  let ar = Array.init 876 I.of_int in
  let a1 = A.map_from_array f ar in
  let a2 = A.init 876 (fun x -> I.of_int (2 * x)) in
  assert (A.equal a1 a2);
  let a = A.map_from_array (fun _ -> assert false) [| |] in
  assert (A.equal a (A.make 0 0{{SUFFIX}}));

  (* comparisons *)
  (* No polymorphic compare yet *)
  (* let normalize_comparison n =
    if n = 0 then 0 else if n < 0 then -1 else 1
  in
  let check c l1 l2 =
    assert (c = (normalize_comparison (compare (A.of_list l1) (A.of_list l2))))
  in
  check 0    [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; I.min_int]
             [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; I.min_int];
  check (-1) [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; I.min_int]
             [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; I.(add min_int 1{{SUFFIX}})];
  check (-1) [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; 45096843{{SUFFIX}}]
             [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; 45096844{{SUFFIX}}];
  check 1    [0{{SUFFIX}}; 2{{SUFFIX}}; -4{{SUFFIX}}]
             [0{{SUFFIX}}; 0{{SUFFIX}}; 3{{SUFFIX}}];
  check 1    [0{{SUFFIX}}; 2{{SUFFIX}}; -4{{SUFFIX}}]
             [I.min_int; 0{{SUFFIX}}; 3{{SUFFIX}}]; *)

  (* [unsafe_get] [unsafe_set] *)
  let a = A.make 3 0{{SUFFIX}} in
  for i = 0 to 2 do A.unsafe_set a i (I.of_int i) done;
  for i = 0 to 2 do assert (A.unsafe_get a i = I.of_int i) done;

  let a = A.make 4 0{{SUFFIX}} in
  for i = 0 to 3 do A.unsafe_set a i (I.of_int i) done;
  for i = 0 to 3 do assert (A.unsafe_get a i = I.of_int i) done;

  (* I/O *)
  (* No marshalling yet *)
  (* let test_structured_io value =
    let (tmp, oc) =
      Filename.open_temp_file ~mode:[Open_binary] "int64_array" ".data"
    in
    Marshal.to_channel oc value [];
    close_out oc;
    let ic = open_in_bin tmp in
    let value' = Marshal.from_channel ic in
    close_in ic;
    Sys.remove tmp;
    assert (compare value value' = 0)
  in
  let l = [0{{SUFFIX}}; 1{{SUFFIX}}; -4{{SUFFIX}}; I.max_int; I.min_int; 31415926{{SUFFIX}}] in
  test_structured_io (A.of_list l); *)

end

module T = Test ({{BOXED_MODULE}}_array)
module T2 = Test ({{MODULE_NAME}})

(* Extra tests for functions not covered above *)
module {{ELEMENT_MODULE}} = Stdlib__{{ELEMENT_MODULE}}
let () =
  let open Std_{{MODULE_NAME}} in
  let module I = {{BOXED_MODULE}} in
  let to_boxed = {{ELEMENT_MODULE}}.to_{{BOXED_TYPE}} in
  let u_of_int = {{ELEMENT_MODULE}}.of_int in
  let (+.) x y = I.add x y in
  let rec check_i_upto a i =
    if i >= 0 then begin
      assert (to_boxed (get a i) = I.of_int i);
      check_i_upto a (i - 1);
    end
  in

  let check_i a = check_i_upto a (length a - 1) in
  let check_inval f arg =
    match f arg with
    | _ -> assert false
    | exception (Invalid_argument _) -> ()
    | exception _ -> assert false
  in

  (* make_matrix *)
  check_inval (make_matrix (-1) 1) (u_of_int 1);
  check_inval (make_matrix 1 (-1)) (u_of_int 1);
  let check_matrix a =
    let row_len = Array.length a in
    assert (row_len > 0);
    let col_len = length (a.(0)) in
    for row = 0 to (row_len - 1) do
      assert (length (a.(row)) = col_len);
      for col = 0 to (col_len - 1) do
        assert {{ELEMENT_MODULE}}.(equal (get (a.(row)) col) (of_int 1))
      done
    done in
  let a = make_matrix 100 100 (u_of_int 1) in
  check_matrix a;
  let a = make_matrix 101 100 (u_of_int 1) in
  check_matrix a;
  let a = make_matrix 101 101 (u_of_int 1) in
  check_matrix a;
  let a = make_matrix 100 101 (u_of_int 1) in
  check_matrix a;

  (* for_all2 *)
  let test a =
    let r = ref 0{{SUFFIX}} in
    let f x y =
      let x = to_boxed x in
      let y = to_boxed y in
      assert (x = !r);
      assert (y = !r);
      r := x +. 1{{SUFFIX}};
      true
    in
    assert (for_all2 f a a);
    let f x y =
      let x = to_boxed x in
      let y = to_boxed y in
      assert (x = 0{{SUFFIX}}); assert (y = 0{{SUFFIX}}); false in
    if length a > 0 then assert (not (for_all2 f a a))

  in
  let a = init 777 u_of_int in
  test a;
  let a = init 778 u_of_int in
  test a;
  let a = init 0 u_of_int in
  test a;
  check_inval (fun x -> for_all2 (fun _ _ -> true) (make 100 x) (make 101 x))
    (u_of_int 1);

  (* exists2 *)
  let test a =
    let r = ref 0{{SUFFIX}} in
    let f x y =
      let x = to_boxed x in
      let y = to_boxed y in
      assert (x = !r);
      assert (y = !r);
      r := x +. 1{{SUFFIX}};
      false
    in
    assert (not (exists2 f a a));
    let f x y =
      let x = to_boxed x in
      let y = to_boxed y in
      assert (x = 0{{SUFFIX}}); assert (y = 0{{SUFFIX}}); true in
    if length a > 0 then assert (exists2 f a a)

  in
  let a = init 777 u_of_int in
  test a;
  let a = init 778 u_of_int in
  test a;
  let a = init 0 u_of_int in
  test a;
  check_inval (fun x -> exists2 (fun _ _ -> true) (make 100 x) (make 101 x))
    (u_of_int 1);

  (* static blocks *)
  let r = [| #0{{SUFFIX}}; #1{{SUFFIX}}; #2{{SUFFIX}}; #3{{SUFFIX}}; #4{{SUFFIX}}; #5{{SUFFIX}};
             #6{{SUFFIX}}; #7{{SUFFIX}}; #8{{SUFFIX}}; #9{{SUFFIX}}; #10{{SUFFIX}}; #11{{SUFFIX}};
             #12{{SUFFIX}}; #13{{SUFFIX}}; #14{{SUFFIX}}; #15{{SUFFIX}}; #16{{SUFFIX}}; #17{{SUFFIX}};
             #18{{SUFFIX}}; #19{{SUFFIX}}; #20{{SUFFIX}}; #21{{SUFFIX}}; #22{{SUFFIX}}; #23{{SUFFIX}};
             #24{{SUFFIX}}; #25{{SUFFIX}}; #26{{SUFFIX}}; #27{{SUFFIX}}; #28{{SUFFIX}}; #29{{SUFFIX}};
             #30{{SUFFIX}}; #31{{SUFFIX}}; #32{{SUFFIX}}; #33{{SUFFIX}}; #34{{SUFFIX}}; #35{{SUFFIX}};
             #36{{SUFFIX}}; #37{{SUFFIX}}; #38{{SUFFIX}}; #39{{SUFFIX}}; #40{{SUFFIX}}; #41{{SUFFIX}};
             #42{{SUFFIX}}; #43{{SUFFIX}}; #44{{SUFFIX}}; #45{{SUFFIX}}; #46{{SUFFIX}}; #47{{SUFFIX}};
             #48{{SUFFIX}}; #49{{SUFFIX}}; #50{{SUFFIX}}; #51{{SUFFIX}}; #52{{SUFFIX}}; #53{{SUFFIX}};
             #54{{SUFFIX}}; #55{{SUFFIX}}; #56{{SUFFIX}}; #57{{SUFFIX}}; #58{{SUFFIX}}; #59{{SUFFIX}};
             #60{{SUFFIX}}; #61{{SUFFIX}}; #62{{SUFFIX}}; #63{{SUFFIX}}; #64{{SUFFIX}}; #65{{SUFFIX}};
             #66{{SUFFIX}}; #67{{SUFFIX}}; #68{{SUFFIX}}; #69{{SUFFIX}}; #70{{SUFFIX}}; #71{{SUFFIX}};
             #72{{SUFFIX}}; #73{{SUFFIX}}; #74{{SUFFIX}}; #75{{SUFFIX}}; #76{{SUFFIX}}; #77{{SUFFIX}};
             #78{{SUFFIX}}; #79{{SUFFIX}}; #80{{SUFFIX}}; #81{{SUFFIX}}; #82{{SUFFIX}}; #83{{SUFFIX}};
             #84{{SUFFIX}}; #85{{SUFFIX}}; #86{{SUFFIX}}; #87{{SUFFIX}}; #88{{SUFFIX}}; #89{{SUFFIX}};
             #90{{SUFFIX}}; #91{{SUFFIX}}; #92{{SUFFIX}}; #93{{SUFFIX}}; #94{{SUFFIX}}; #95{{SUFFIX}};
             #96{{SUFFIX}}; #97{{SUFFIX}}; #98{{SUFFIX}}; #99{{SUFFIX}}; #100{{SUFFIX}}; #101{{SUFFIX}};
             #102{{SUFFIX}}; #103{{SUFFIX}}; #104{{SUFFIX}}; #105{{SUFFIX}}; #106{{SUFFIX}}; #107{{SUFFIX}};
             #108{{SUFFIX}}; #109{{SUFFIX}}; #110{{SUFFIX}}; #111{{SUFFIX}}; #112{{SUFFIX}}; #113{{SUFFIX}};
             #114{{SUFFIX}}; #115{{SUFFIX}}; #116{{SUFFIX}}; #117{{SUFFIX}}; #118{{SUFFIX}}; #119{{SUFFIX}};
             #120{{SUFFIX}}; #121{{SUFFIX}}; #122{{SUFFIX}}; #123{{SUFFIX}}; #124{{SUFFIX}}; #125{{SUFFIX}};
             #126{{SUFFIX}}; #127{{SUFFIX}}; #128{{SUFFIX}}; #129{{SUFFIX}}; #130{{SUFFIX}}; #131{{SUFFIX}};
             #132{{SUFFIX}}; #133{{SUFFIX}}; #134{{SUFFIX}}; #135{{SUFFIX}}; #136{{SUFFIX}}; #137{{SUFFIX}};
             #138{{SUFFIX}}; #139{{SUFFIX}}; #140{{SUFFIX}}; #141{{SUFFIX}}; #142{{SUFFIX}}; #143{{SUFFIX}};
             #144{{SUFFIX}}; #145{{SUFFIX}}; #146{{SUFFIX}}; #147{{SUFFIX}}; #148{{SUFFIX}}; #149{{SUFFIX}};
             #150{{SUFFIX}}; #151{{SUFFIX}}; #152{{SUFFIX}}; #153{{SUFFIX}}; #154{{SUFFIX}}; #155{{SUFFIX}};
             #156{{SUFFIX}}; #157{{SUFFIX}}; #158{{SUFFIX}}; #159{{SUFFIX}}; #160{{SUFFIX}}; #161{{SUFFIX}};
             #162{{SUFFIX}}; #163{{SUFFIX}}; #164{{SUFFIX}}; #165{{SUFFIX}}; #166{{SUFFIX}}; #167{{SUFFIX}};
             #168{{SUFFIX}}; #169{{SUFFIX}}; #170{{SUFFIX}}; #171{{SUFFIX}}; #172{{SUFFIX}}; #173{{SUFFIX}};
             #174{{SUFFIX}}; #175{{SUFFIX}}; #176{{SUFFIX}}; #177{{SUFFIX}}; #178{{SUFFIX}}; #179{{SUFFIX}};
             #180{{SUFFIX}}; #181{{SUFFIX}}; #182{{SUFFIX}}; #183{{SUFFIX}}; #184{{SUFFIX}}; #185{{SUFFIX}};
             #186{{SUFFIX}}; #187{{SUFFIX}}; #188{{SUFFIX}}; #189{{SUFFIX}}; #190{{SUFFIX}}; #191{{SUFFIX}};
             #192{{SUFFIX}}; #193{{SUFFIX}}; #194{{SUFFIX}}; #195{{SUFFIX}}; #196{{SUFFIX}}; #197{{SUFFIX}};
             #198{{SUFFIX}}; #199{{SUFFIX}} |]
  in
  check_i r;
  let r = [| #0{{SUFFIX}}; #1{{SUFFIX}}; #2{{SUFFIX}}; #3{{SUFFIX}}; #4{{SUFFIX}}; #5{{SUFFIX}};
             #6{{SUFFIX}}; #7{{SUFFIX}}; #8{{SUFFIX}}; #9{{SUFFIX}}; #10{{SUFFIX}}; #11{{SUFFIX}};
             #12{{SUFFIX}}; #13{{SUFFIX}}; #14{{SUFFIX}}; #15{{SUFFIX}}; #16{{SUFFIX}}; #17{{SUFFIX}};
             #18{{SUFFIX}}; #19{{SUFFIX}}; #20{{SUFFIX}}; #21{{SUFFIX}}; #22{{SUFFIX}}; #23{{SUFFIX}};
             #24{{SUFFIX}}; #25{{SUFFIX}}; #26{{SUFFIX}}; #27{{SUFFIX}}; #28{{SUFFIX}}; #29{{SUFFIX}};
             #30{{SUFFIX}}; #31{{SUFFIX}}; #32{{SUFFIX}}; #33{{SUFFIX}}; #34{{SUFFIX}}; #35{{SUFFIX}};
             #36{{SUFFIX}}; #37{{SUFFIX}}; #38{{SUFFIX}}; #39{{SUFFIX}}; #40{{SUFFIX}}; #41{{SUFFIX}};
             #42{{SUFFIX}}; #43{{SUFFIX}}; #44{{SUFFIX}}; #45{{SUFFIX}}; #46{{SUFFIX}}; #47{{SUFFIX}};
             #48{{SUFFIX}}; #49{{SUFFIX}}; #50{{SUFFIX}}; #51{{SUFFIX}}; #52{{SUFFIX}}; #53{{SUFFIX}};
             #54{{SUFFIX}}; #55{{SUFFIX}}; #56{{SUFFIX}}; #57{{SUFFIX}}; #58{{SUFFIX}}; #59{{SUFFIX}};
             #60{{SUFFIX}}; #61{{SUFFIX}}; #62{{SUFFIX}}; #63{{SUFFIX}}; #64{{SUFFIX}}; #65{{SUFFIX}};
             #66{{SUFFIX}}; #67{{SUFFIX}}; #68{{SUFFIX}}; #69{{SUFFIX}}; #70{{SUFFIX}}; #71{{SUFFIX}};
             #72{{SUFFIX}}; #73{{SUFFIX}}; #74{{SUFFIX}}; #75{{SUFFIX}}; #76{{SUFFIX}}; #77{{SUFFIX}};
             #78{{SUFFIX}}; #79{{SUFFIX}}; #80{{SUFFIX}}; #81{{SUFFIX}}; #82{{SUFFIX}}; #83{{SUFFIX}};
             #84{{SUFFIX}}; #85{{SUFFIX}}; #86{{SUFFIX}}; #87{{SUFFIX}}; #88{{SUFFIX}}; #89{{SUFFIX}};
             #90{{SUFFIX}}; #91{{SUFFIX}}; #92{{SUFFIX}}; #93{{SUFFIX}}; #94{{SUFFIX}}; #95{{SUFFIX}};
             #96{{SUFFIX}}; #97{{SUFFIX}}; #98{{SUFFIX}}; #99{{SUFFIX}}; #100{{SUFFIX}}; #101{{SUFFIX}};
             #102{{SUFFIX}}; #103{{SUFFIX}}; #104{{SUFFIX}}; #105{{SUFFIX}}; #106{{SUFFIX}}; #107{{SUFFIX}};
             #108{{SUFFIX}}; #109{{SUFFIX}}; #110{{SUFFIX}}; #111{{SUFFIX}}; #112{{SUFFIX}}; #113{{SUFFIX}};
             #114{{SUFFIX}}; #115{{SUFFIX}}; #116{{SUFFIX}}; #117{{SUFFIX}}; #118{{SUFFIX}}; #119{{SUFFIX}};
             #120{{SUFFIX}}; #121{{SUFFIX}}; #122{{SUFFIX}}; #123{{SUFFIX}}; #124{{SUFFIX}}; #125{{SUFFIX}};
             #126{{SUFFIX}}; #127{{SUFFIX}}; #128{{SUFFIX}}; #129{{SUFFIX}}; #130{{SUFFIX}}; #131{{SUFFIX}};
             #132{{SUFFIX}}; #133{{SUFFIX}}; #134{{SUFFIX}}; #135{{SUFFIX}}; #136{{SUFFIX}}; #137{{SUFFIX}};
             #138{{SUFFIX}}; #139{{SUFFIX}}; #140{{SUFFIX}}; #141{{SUFFIX}}; #142{{SUFFIX}}; #143{{SUFFIX}};
             #144{{SUFFIX}}; #145{{SUFFIX}}; #146{{SUFFIX}}; #147{{SUFFIX}}; #148{{SUFFIX}}; #149{{SUFFIX}};
             #150{{SUFFIX}}; #151{{SUFFIX}}; #152{{SUFFIX}}; #153{{SUFFIX}}; #154{{SUFFIX}}; #155{{SUFFIX}};
             #156{{SUFFIX}}; #157{{SUFFIX}}; #158{{SUFFIX}}; #159{{SUFFIX}}; #160{{SUFFIX}}; #161{{SUFFIX}};
             #162{{SUFFIX}}; #163{{SUFFIX}}; #164{{SUFFIX}}; #165{{SUFFIX}}; #166{{SUFFIX}}; #167{{SUFFIX}};
             #168{{SUFFIX}}; #169{{SUFFIX}}; #170{{SUFFIX}}; #171{{SUFFIX}}; #172{{SUFFIX}}; #173{{SUFFIX}};
             #174{{SUFFIX}}; #175{{SUFFIX}}; #176{{SUFFIX}}; #177{{SUFFIX}}; #178{{SUFFIX}}; #179{{SUFFIX}};
             #180{{SUFFIX}}; #181{{SUFFIX}}; #182{{SUFFIX}}; #183{{SUFFIX}}; #184{{SUFFIX}}; #185{{SUFFIX}};
             #186{{SUFFIX}}; #187{{SUFFIX}}; #188{{SUFFIX}}; #189{{SUFFIX}}; #190{{SUFFIX}}; #191{{SUFFIX}};
             #192{{SUFFIX}}; #193{{SUFFIX}}; #194{{SUFFIX}}; #195{{SUFFIX}}; #196{{SUFFIX}}; #197{{SUFFIX}};
             #198{{SUFFIX}}; #199{{SUFFIX}}; #200{{SUFFIX}} |]
  in
  check_i r;
  (* dynamic blocks *)
  let[@inline never] f x = x in
  let r = [| f #0{{SUFFIX}}; f #1{{SUFFIX}}; f #2{{SUFFIX}}; f #3{{SUFFIX}}; f #4{{SUFFIX}}; f #5{{SUFFIX}};
             f #6{{SUFFIX}}; f #7{{SUFFIX}}; f #8{{SUFFIX}}; f #9{{SUFFIX}}; f #10{{SUFFIX}}; f #11{{SUFFIX}};
             f #12{{SUFFIX}}; f #13{{SUFFIX}}; f #14{{SUFFIX}}; f #15{{SUFFIX}}; f #16{{SUFFIX}}; f #17{{SUFFIX}};
             f #18{{SUFFIX}}; f #19{{SUFFIX}}; f #20{{SUFFIX}}; f #21{{SUFFIX}}; f #22{{SUFFIX}}; f #23{{SUFFIX}};
             f #24{{SUFFIX}}; f #25{{SUFFIX}}; f #26{{SUFFIX}}; f #27{{SUFFIX}}; f #28{{SUFFIX}}; f #29{{SUFFIX}};
             f #30{{SUFFIX}}; f #31{{SUFFIX}}; f #32{{SUFFIX}}; f #33{{SUFFIX}}; f #34{{SUFFIX}}; f #35{{SUFFIX}};
             f #36{{SUFFIX}}; f #37{{SUFFIX}}; f #38{{SUFFIX}}; f #39{{SUFFIX}}; f #40{{SUFFIX}}; f #41{{SUFFIX}};
             f #42{{SUFFIX}}; f #43{{SUFFIX}}; f #44{{SUFFIX}}; f #45{{SUFFIX}}; f #46{{SUFFIX}}; f #47{{SUFFIX}};
             f #48{{SUFFIX}}; f #49{{SUFFIX}}; f #50{{SUFFIX}}; f #51{{SUFFIX}}; f #52{{SUFFIX}}; f #53{{SUFFIX}};
             f #54{{SUFFIX}}; f #55{{SUFFIX}}; f #56{{SUFFIX}}; f #57{{SUFFIX}}; f #58{{SUFFIX}}; f #59{{SUFFIX}};
             f #60{{SUFFIX}}; f #61{{SUFFIX}}; f #62{{SUFFIX}}; f #63{{SUFFIX}}; f #64{{SUFFIX}}; f #65{{SUFFIX}};
             f #66{{SUFFIX}}; f #67{{SUFFIX}}; f #68{{SUFFIX}}; f #69{{SUFFIX}}; f #70{{SUFFIX}}; f #71{{SUFFIX}};
             f #72{{SUFFIX}}; f #73{{SUFFIX}}; f #74{{SUFFIX}}; f #75{{SUFFIX}}; f #76{{SUFFIX}}; f #77{{SUFFIX}};
             f #78{{SUFFIX}}; f #79{{SUFFIX}}; f #80{{SUFFIX}}; f #81{{SUFFIX}}; f #82{{SUFFIX}}; f #83{{SUFFIX}};
             f #84{{SUFFIX}}; f #85{{SUFFIX}}; f #86{{SUFFIX}}; f #87{{SUFFIX}}; f #88{{SUFFIX}}; f #89{{SUFFIX}};
             f #90{{SUFFIX}}; f #91{{SUFFIX}}; f #92{{SUFFIX}}; f #93{{SUFFIX}}; f #94{{SUFFIX}}; f #95{{SUFFIX}};
             f #96{{SUFFIX}}; f #97{{SUFFIX}}; f #98{{SUFFIX}}; f #99{{SUFFIX}}; f #100{{SUFFIX}}; f #101{{SUFFIX}};
             f #102{{SUFFIX}}; f #103{{SUFFIX}}; f #104{{SUFFIX}}; f #105{{SUFFIX}}; f #106{{SUFFIX}}; f #107{{SUFFIX}};
             f #108{{SUFFIX}}; f #109{{SUFFIX}}; f #110{{SUFFIX}}; f #111{{SUFFIX}}; f #112{{SUFFIX}}; f #113{{SUFFIX}};
             f #114{{SUFFIX}}; f #115{{SUFFIX}}; f #116{{SUFFIX}}; f #117{{SUFFIX}}; f #118{{SUFFIX}}; f #119{{SUFFIX}};
             f #120{{SUFFIX}}; f #121{{SUFFIX}}; f #122{{SUFFIX}}; f #123{{SUFFIX}}; f #124{{SUFFIX}}; f #125{{SUFFIX}};
             f #126{{SUFFIX}}; f #127{{SUFFIX}}; f #128{{SUFFIX}}; f #129{{SUFFIX}}; f #130{{SUFFIX}}; f #131{{SUFFIX}};
             f #132{{SUFFIX}}; f #133{{SUFFIX}}; f #134{{SUFFIX}}; f #135{{SUFFIX}}; f #136{{SUFFIX}}; f #137{{SUFFIX}};
             f #138{{SUFFIX}}; f #139{{SUFFIX}}; f #140{{SUFFIX}}; f #141{{SUFFIX}}; f #142{{SUFFIX}}; f #143{{SUFFIX}};
             f #144{{SUFFIX}}; f #145{{SUFFIX}}; f #146{{SUFFIX}}; f #147{{SUFFIX}}; f #148{{SUFFIX}}; f #149{{SUFFIX}};
             f #150{{SUFFIX}}; f #151{{SUFFIX}}; f #152{{SUFFIX}}; f #153{{SUFFIX}}; f #154{{SUFFIX}}; f #155{{SUFFIX}};
             f #156{{SUFFIX}}; f #157{{SUFFIX}}; f #158{{SUFFIX}}; f #159{{SUFFIX}}; f #160{{SUFFIX}}; f #161{{SUFFIX}};
             f #162{{SUFFIX}}; f #163{{SUFFIX}}; f #164{{SUFFIX}}; f #165{{SUFFIX}}; f #166{{SUFFIX}}; f #167{{SUFFIX}};
             f #168{{SUFFIX}}; f #169{{SUFFIX}}; f #170{{SUFFIX}}; f #171{{SUFFIX}}; f #172{{SUFFIX}}; f #173{{SUFFIX}};
             f #174{{SUFFIX}}; f #175{{SUFFIX}}; f #176{{SUFFIX}}; f #177{{SUFFIX}}; f #178{{SUFFIX}}; f #179{{SUFFIX}};
             f #180{{SUFFIX}}; f #181{{SUFFIX}}; f #182{{SUFFIX}}; f #183{{SUFFIX}}; f #184{{SUFFIX}}; f #185{{SUFFIX}};
             f #186{{SUFFIX}}; f #187{{SUFFIX}}; f #188{{SUFFIX}}; f #189{{SUFFIX}}; f #190{{SUFFIX}}; f #191{{SUFFIX}};
             f #192{{SUFFIX}}; f #193{{SUFFIX}}; f #194{{SUFFIX}}; f #195{{SUFFIX}}; f #196{{SUFFIX}}; f #197{{SUFFIX}};
             f #198{{SUFFIX}}; f #199{{SUFFIX}} |]
  in
  check_i r;
  let r = [| f #0{{SUFFIX}}; f #1{{SUFFIX}}; f #2{{SUFFIX}}; f #3{{SUFFIX}}; f #4{{SUFFIX}}; f #5{{SUFFIX}};
             f #6{{SUFFIX}}; f #7{{SUFFIX}}; f #8{{SUFFIX}}; f #9{{SUFFIX}}; f #10{{SUFFIX}}; f #11{{SUFFIX}};
             f #12{{SUFFIX}}; f #13{{SUFFIX}}; f #14{{SUFFIX}}; f #15{{SUFFIX}}; f #16{{SUFFIX}}; f #17{{SUFFIX}};
             f #18{{SUFFIX}}; f #19{{SUFFIX}}; f #20{{SUFFIX}}; f #21{{SUFFIX}}; f #22{{SUFFIX}}; f #23{{SUFFIX}};
             f #24{{SUFFIX}}; f #25{{SUFFIX}}; f #26{{SUFFIX}}; f #27{{SUFFIX}}; f #28{{SUFFIX}}; f #29{{SUFFIX}};
             f #30{{SUFFIX}}; f #31{{SUFFIX}}; f #32{{SUFFIX}}; f #33{{SUFFIX}}; f #34{{SUFFIX}}; f #35{{SUFFIX}};
             f #36{{SUFFIX}}; f #37{{SUFFIX}}; f #38{{SUFFIX}}; f #39{{SUFFIX}}; f #40{{SUFFIX}}; f #41{{SUFFIX}};
             f #42{{SUFFIX}}; f #43{{SUFFIX}}; f #44{{SUFFIX}}; f #45{{SUFFIX}}; f #46{{SUFFIX}}; f #47{{SUFFIX}};
             f #48{{SUFFIX}}; f #49{{SUFFIX}}; f #50{{SUFFIX}}; f #51{{SUFFIX}}; f #52{{SUFFIX}}; f #53{{SUFFIX}};
             f #54{{SUFFIX}}; f #55{{SUFFIX}}; f #56{{SUFFIX}}; f #57{{SUFFIX}}; f #58{{SUFFIX}}; f #59{{SUFFIX}};
             f #60{{SUFFIX}}; f #61{{SUFFIX}}; f #62{{SUFFIX}}; f #63{{SUFFIX}}; f #64{{SUFFIX}}; f #65{{SUFFIX}};
             f #66{{SUFFIX}}; f #67{{SUFFIX}}; f #68{{SUFFIX}}; f #69{{SUFFIX}}; f #70{{SUFFIX}}; f #71{{SUFFIX}};
             f #72{{SUFFIX}}; f #73{{SUFFIX}}; f #74{{SUFFIX}}; f #75{{SUFFIX}}; f #76{{SUFFIX}}; f #77{{SUFFIX}};
             f #78{{SUFFIX}}; f #79{{SUFFIX}}; f #80{{SUFFIX}}; f #81{{SUFFIX}}; f #82{{SUFFIX}}; f #83{{SUFFIX}};
             f #84{{SUFFIX}}; f #85{{SUFFIX}}; f #86{{SUFFIX}}; f #87{{SUFFIX}}; f #88{{SUFFIX}}; f #89{{SUFFIX}};
             f #90{{SUFFIX}}; f #91{{SUFFIX}}; f #92{{SUFFIX}}; f #93{{SUFFIX}}; f #94{{SUFFIX}}; f #95{{SUFFIX}};
             f #96{{SUFFIX}}; f #97{{SUFFIX}}; f #98{{SUFFIX}}; f #99{{SUFFIX}}; f #100{{SUFFIX}}; f #101{{SUFFIX}};
             f #102{{SUFFIX}}; f #103{{SUFFIX}}; f #104{{SUFFIX}}; f #105{{SUFFIX}}; f #106{{SUFFIX}}; f #107{{SUFFIX}};
             f #108{{SUFFIX}}; f #109{{SUFFIX}}; f #110{{SUFFIX}}; f #111{{SUFFIX}}; f #112{{SUFFIX}}; f #113{{SUFFIX}};
             f #114{{SUFFIX}}; f #115{{SUFFIX}}; f #116{{SUFFIX}}; f #117{{SUFFIX}}; f #118{{SUFFIX}}; f #119{{SUFFIX}};
             f #120{{SUFFIX}}; f #121{{SUFFIX}}; f #122{{SUFFIX}}; f #123{{SUFFIX}}; f #124{{SUFFIX}}; f #125{{SUFFIX}};
             f #126{{SUFFIX}}; f #127{{SUFFIX}}; f #128{{SUFFIX}}; f #129{{SUFFIX}}; f #130{{SUFFIX}}; f #131{{SUFFIX}};
             f #132{{SUFFIX}}; f #133{{SUFFIX}}; f #134{{SUFFIX}}; f #135{{SUFFIX}}; f #136{{SUFFIX}}; f #137{{SUFFIX}};
             f #138{{SUFFIX}}; f #139{{SUFFIX}}; f #140{{SUFFIX}}; f #141{{SUFFIX}}; f #142{{SUFFIX}}; f #143{{SUFFIX}};
             f #144{{SUFFIX}}; f #145{{SUFFIX}}; f #146{{SUFFIX}}; f #147{{SUFFIX}}; f #148{{SUFFIX}}; f #149{{SUFFIX}};
             f #150{{SUFFIX}}; f #151{{SUFFIX}}; f #152{{SUFFIX}}; f #153{{SUFFIX}}; f #154{{SUFFIX}}; f #155{{SUFFIX}};
             f #156{{SUFFIX}}; f #157{{SUFFIX}}; f #158{{SUFFIX}}; f #159{{SUFFIX}}; f #160{{SUFFIX}}; f #161{{SUFFIX}};
             f #162{{SUFFIX}}; f #163{{SUFFIX}}; f #164{{SUFFIX}}; f #165{{SUFFIX}}; f #166{{SUFFIX}}; f #167{{SUFFIX}};
             f #168{{SUFFIX}}; f #169{{SUFFIX}}; f #170{{SUFFIX}}; f #171{{SUFFIX}}; f #172{{SUFFIX}}; f #173{{SUFFIX}};
             f #174{{SUFFIX}}; f #175{{SUFFIX}}; f #176{{SUFFIX}}; f #177{{SUFFIX}}; f #178{{SUFFIX}}; f #179{{SUFFIX}};
             f #180{{SUFFIX}}; f #181{{SUFFIX}}; f #182{{SUFFIX}}; f #183{{SUFFIX}}; f #184{{SUFFIX}}; f #185{{SUFFIX}};
             f #186{{SUFFIX}}; f #187{{SUFFIX}}; f #188{{SUFFIX}}; f #189{{SUFFIX}}; f #190{{SUFFIX}}; f #191{{SUFFIX}};
             f #192{{SUFFIX}}; f #193{{SUFFIX}}; f #194{{SUFFIX}}; f #195{{SUFFIX}}; f #196{{SUFFIX}}; f #197{{SUFFIX}};
             f #198{{SUFFIX}}; f #199{{SUFFIX}}; f #200{{SUFFIX}} |]
  in
  check_i r;
  check_i [| #0{{SUFFIX}}; ((fun x -> x) #1{{SUFFIX}})|];
  check_i [| #0{{SUFFIX}}; ((fun x -> x) #1{{SUFFIX}}); #2{{SUFFIX}}|];

  let () =
    let (=) = {{ELEMENT_MODULE}}.equal in
    (* match statement *)
    let d = [| #1{{SUFFIX}}; #2{{SUFFIX}} |] in
    (match d with
      | [| a; b |] ->
        assert (a = #1{{SUFFIX}});
        assert (b = #2{{SUFFIX}})
      | _ -> assert false);

    (* let statement pattern *)
    let a = [||] in
    let b = [| #1{{SUFFIX}} |] in
    let c = append a b in
    let[@warning "-8"] [| d |] = c in
    assert (d = #1{{SUFFIX}});

    (* function argument pattern *)
    let[@warning "-8"] f [| b |] = b in
    assert (f [| #1{{SUFFIX}} |] = #1{{SUFFIX}})
  in
  ()
