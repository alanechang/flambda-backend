# Run this script
import re
import os

warning_comment = 'Do not edit this file directly.\n\
   Change "*.ml.template" files and run "gen.py" instead.'
array_lib_template_file = './gen_u_array.ml.template'
array_lib_configs = {
  'int32_u_array.ml': {
    'jkind': 'bits32',
    'module_name': 'Int32_u_array',
    'make_prim_bytecode': 'caml_make_unboxed_int32_vect_bytecode',
    'make_prim_native': 'caml_make_unboxed_int32_vect',
    'blit_prim_bytecode': 'caml_array_blit',
    'blit_prim_native': 'caml_unboxed_int32_vect_blit',
    'to_boxed_prim': '%box_int32',
    'boxed_type': 'int32',
    'boxed_module': 'Int32',

    'warning_comment': warning_comment,
  },
  'int64_u_array.ml': {
    'jkind': 'bits64',
    'module_name': 'Int64_u_array',
    'make_prim_bytecode': 'caml_make_unboxed_int64_vect_bytecode',
    'make_prim_native': 'caml_make_unboxed_int64_vect',
    'blit_prim_bytecode': 'caml_array_blit',
    'blit_prim_native': 'caml_unboxed_int64_vect_blit',
    'to_boxed_prim': '%box_int64',
    'boxed_type': 'int64',
    'boxed_module': 'Int64',

    'warning_comment': warning_comment,
  },
  'nativeint_u_array.ml': {
    'jkind': 'word',
    'module_name': 'Nativeint_u_array',
    'make_prim_bytecode': 'caml_make_unboxed_nativeint_vect_bytecode',
    'make_prim_native': 'caml_make_unboxed_nativeint_vect',
    'blit_prim_bytecode': 'caml_array_blit',
    'blit_prim_native': 'caml_unboxed_nativeint_vect_blit',
    'to_boxed_prim': '%box_nativeint',
    'boxed_type': 'nativeint',
    'boxed_module': 'Nativeint',

    'warning_comment': warning_comment,
  }
}

array_test_template_file = './gen_test_u_array.ml.template'
array_test_configs = {
  'test_int32_u_array.ml': {
    'module_name': 'Int32_u_array',
    'boxed_type': 'int32',
    'boxed_module': 'Int32',
    'element_module': 'Int32_u',
    'unboxed_type': 'int32#',
    'suffix': 'l',

    # this is here so that the template itself is not treated as a test
    'test_header': 'TEST',
    'warning_comment': warning_comment,
  },

  'test_int64_u_array.ml': {
    'module_name': 'Int64_u_array',
    'boxed_type': 'int64',
    'boxed_module': 'Int64',
    'element_module': 'Int64_u',
    'unboxed_type': 'int64#',
    'suffix': 'L',

    # this is here so that the template itself is not treated as a test
    'test_header': 'TEST',
    'warning_comment': warning_comment,
  },

  'test_nativeint_u_array.ml': {
    'module_name': 'Nativeint_u_array',
    'boxed_type': 'nativeint',
    'boxed_module': 'Nativeint',
    'element_module': 'Nativeint_u',
    'unboxed_type': 'nativeint#',
    'suffix': 'n',

    # this is here so that the template itself is not treated as a test
    'test_header': 'TEST',
    'warning_comment': warning_comment,
  },
}

def generate_from_template(template_file, configs):
  with open(template_file, 'r') as f:
    template = f.read()

  for filename, config in configs.items():
    output = template
    for key, value in config.items():
      text = '{{' + key.upper() + '}}'

      if text not in output:
        print(f'{text} not found in {template_file}.')
        exit(-1)

      output = output.replace(text, value)
    remaining = re.findall("{{.*?}}", output)
    if len(remaining) > 0:
      print(f'remaining replacement patterns found when generating {filename}! {remaining}')
      exit(-1)
    with open(filename, 'w') as f:
      f.write(output)
    print(f'Generated {filename}')
  print(f'All done with template {template_file}')

if __name__ == '__main__':
  # change to the script dir
  script_dir = os.path.dirname(os.path.abspath(__file__))
  os.chdir(script_dir)

  generate_from_template(array_lib_template_file, array_lib_configs)
  generate_from_template(array_test_template_file, array_test_configs)
